// import { FileHandle } from 'node:fs/promises';

// import { generateOrdering } from './ordering';
// import { shNames } from './ply';
// import { GaussianRef } from './ply-data';
// import { version } from '../package.json';
// import { GaussianData } from './gaussian-data';
// import { CompressedChunk } from './compressed-chunk';

// const generatedByString = `Generated by splat-transform ${version}`;
// const shBandCoeffs = [0, 3, 8, 15];

// const chunkProps = [
//     'min_x', 'min_y', 'min_z',
//     'max_x', 'max_y', 'max_z',
//     'min_scale_x', 'min_scale_y', 'min_scale_z',
//     'max_scale_x', 'max_scale_y', 'max_scale_z',
//     'min_r', 'min_g', 'min_b',
//     'max_r', 'max_g', 'max_b'
// ];

// const vertexProps = [
//     'packed_position',
//     'packed_rotation',
//     'packed_scale',
//     'packed_color'
// ];

// const writeCompressedPly = async (fileHandle: FileHandle, refs: GaussianRef[], shBands: number) => {
//     const outputSHCoeffs = shBandCoeffs[shBands];

//     const numSplats = refs.length;
//     const numChunks = Math.ceil(numSplats / 256);

//     const shHeader = shBands ? [
//         `element sh ${numSplats}`,
//         new Array(outputSHCoeffs * 3).fill('').map((_, i) => `property uchar f_rest_${i}`)
//     ].flat() : [];

//     const headerText = [
//         'ply',
//         'format binary_little_endian 1.0',
//         `comment ${generatedByString}`,
//         `element chunk ${numChunks}`,
//         chunkProps.map(p => `property float ${p}`),
//         `element vertex ${numSplats}`,
//         vertexProps.map(p => `property uint ${p}`),
//         shHeader,
//         'end_header\n'
//     ].flat().join('\n');

//     const header = (new TextEncoder()).encode(headerText);
//     const chunkData = new Float32Array(numChunks * chunkProps.length);
//     const splatIData = new Uint32Array(numSplats * vertexProps.length);
//     const shData = new Uint8Array(numSplats * outputSHCoeffs * 3);

//     // sort splats into some kind of order (morton order rn)
//     const sortIndices = generateOrdering(refs);

//     const gaussianData = new GaussianData(CompressedChunk.members);

//     const shMembers = shNames.slice(0, outputSHCoeffs * 3);
//     const shGaussianData = new GaussianData(shMembers);

//     const chunk = new CompressedChunk();

//     for (let i = 0; i < numChunks; ++i) {
//         const num = Math.min(numSplats, (i + 1) * 256) - i * 256;
//         for (let j = 0; j < num; ++j) {
//             const index = sortIndices[i * 256 + j];

//             // read splat data
//             gaussianData.read(refs[index].splat, refs[index].i);

//             // update chunk
//             chunk.set(j, gaussianData);

//             // read spherical harmonics
//             shGaussianData.read(refs[index].splat, refs[index].i);

//             // quantize and write sh data
//             let off = (i * 256 + j) * outputSHCoeffs * 3;
//             for (let k = 0; k < outputSHCoeffs * 3; ++k) {
//                 const nvalue = shGaussianData.buffer[k] / 8 + 0.5;
//                 shData[off++] = Math.max(0, Math.min(255, Math.trunc(nvalue * 256)));
//             }
//         }

//         // repeat the last gaussian to fill the rest of the final chunk
//         for (let j = num; j < 256; ++j) {
//             chunk.set(j, gaussianData);
//         }

//         // pack the chunk
//         chunk.pack();

//         // store the float data
//         chunkData.set(chunk.chunkData, i * 18);

//         // write packed bits
//         const offset = i * 256 * 4;
//         for (let j = 0; j < num; ++j) {
//             splatIData[offset + j * 4 + 0] = chunk.position[j];
//             splatIData[offset + j * 4 + 1] = chunk.rotation[j];
//             splatIData[offset + j * 4 + 2] = chunk.scale[j];
//             splatIData[offset + j * 4 + 3] = chunk.color[j];
//         }
//     }

//     await fileHandle.write(header);
//     await fileHandle.write(new Uint8Array(chunkData.buffer));
//     await fileHandle.write(new Uint8Array(splatIData.buffer));
//     await fileHandle.write(shData);
// };

// export { GaussianRef, writeCompressedPly };
